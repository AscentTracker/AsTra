#!/usr/bin/perl

# TODO:
# -document and comment :)
#
#

use warnings;
use strict;


use utf8;

use JSON;
use Date::Parse;
use File::Touch;
use File::Copy;
use File::Path;
use Data::Dumper;
use Encode;

my $verbose;

use Getopt::Long;
my $result = GetOptions (
                         "verbose"  => \$verbose);  # flag

my %sessionfiles;

# group session files for each day
foreach my $file (sort @ARGV) {    
    if ($file =~ /(\d\d\d\d\d\d)\w\w.CSV$/i) {
	my $day=$1;
	push(@{$sessionfiles{$day}},$file);
    };
};    

# process each days worth of climbing sessions
foreach my $day (sort keys %sessionfiles) {
    # print "$day ". join(' ',@{$sessionfiles{$day}})."\n";    
    oneSession(@{$sessionfiles{$day}});
};

exit 0;

sub oneSession {
    my @files=@_;

    my %climbers;
    my %ascends;
    my %times;
    my %locations;

    my $labels='';
    my $num=1;
    my %labels;

    my %totals;
    
    my $date;
    my $location;
    
file: foreach my $file (@files) {  
    
    open(IN,$file) or do {warn("Cannot read $file\n"), next};
    my $alt=0;
    my $line=<IN>;
    next file unless defined $line;
    next file unless $line =~ /"file":/; # skip old files with no JSON data

    print "Reading file $file\n" if $verbose;
    
    # force? correct encoding
    $line=encode_utf8($line);
    
    my %d = %{decode_json($line)};
    
    # print Dumper(\%d);
    $date=$d{date};
    my $hhmm=join(':',(split(/:/,$d{time}))[0..1]);
    my $timestamp=$d{date}." ".$d{time};
    $location=$d{location};

    unless ($location) {
	print "No location in $file\n";
	next file;
    };
    
    # read data
    # millis, raw, avg, kalman, voltage, ...
    # 3885,-0.07,-0.03,0.01,5.00, ...
    my %filesecs=();
    my $sec=0;
    my $maxtime=0;
    my %thistimes=();
    my %thisascend=();
    my $maxalt=0;
    my $failed="&nbsp;";
    while (my $line=<IN>) {
	next if $line =~ /^#/;
	if ($line =~ /FAILED/) {
	    $failed='-';
	    next;
	};
	my($millis,$raw,$avg,$kalman,$volts)=split(/[\,\s]+/, $line);
	next if $kalman < 0.0;
	next if $kalman > 20.0;
	$sec=int($millis/500)*0.5;
	# $thistimes{$sec}++; # collect timeslots for all datasets
	# $thisascend{$sec}=$kalman, $maxalt=$maxalt<$kalman?$kalman:$maxalt unless $filesecs{$sec}++; # only first data for every timeslot
	unless ($filesecs{$sec}++) { # only first data for every timeslot
	    $thisascend{$sec}=$kalman;
	    if ($kalman>=$maxalt) {
		$maxalt=$kalman;
		$maxtime=$sec;
	    };
	};
    };
    close(IN);
    
    # For filesystem convenience: set file date to climbing date
    my $filetime=str2time($timestamp);
    my $ref = File::Touch->new(time => $filetime);
    my $count = $ref->touch($file);
        
    # Only ascends longer than this and higher than that are included
    if ($sec>30 and $maxalt > 1.0) {
	my $climber=$d{climber};
	$climbers{$climber}++;
	
	$locations{$climber}{$location}++;
    	
	# print "$file $ftime $climber $grade\n";
	my $grade=$d{grade};
	my $duration=int(($maxtime/60.0));
	# my $duration2=int(($sec/60.0));
	my $maxalt=int($maxalt+0.5);
	my $label="$failed$grade $hhmm+$duration&gt;$maxalt";
	$totals{$climber}{$location}{'duration'}+=$duration;
	$totals{$climber}{$location}{'maxaltsum'}+=$maxalt;
	$totals{$climber}{$location}{'routes'}++;
	# $labels{$location}.= "\"$label\",";
	push(@{$labels{$climber}{$location}},$label);
	foreach my $sec (keys %thisascend) {	
	    $times{$climber}{$location}{$sec}++; # collect timeslots for all datasets
	    $ascends{$climber}{$location}{$label}{$sec}=$thisascend{$sec};
	};
    } else {
	# print "Skip $sec $file\n";
    };
};

# print "\"secs\",$labels\n";
# print Dumper(\%climbers);      
# print Dumper(\%times);
# print Dumper(\%totals);
# print Dumper(\%labels);
# print Dumper(\%locations);
# exit 0;
    
# chop($labels);
    
foreach my $climber (sort keys %climbers) {

    # make directory for each climber
    my $dir="www/$climber";
    mkpath($dir); # no error if created already

    # link to a .htaccess that tidies up the directory listing (Apache www server)
    symlink("../htaccess","$dir/.htaccess");    

  foreach my $location (sort keys %{$locations{$climber}}) {  
    
    my $locf=$location; # make a filesystem safe location name
    $locf =~ s/\s/_/g; # spaces to underlines
    $locf =~ s/[^A-Za-z]/\-/g; # other non-word characters to hyphens
    my $csvfile="$dir/$date-$locf.csv";
    # print "$locf\n";
    open(CSV, ">$csvfile") or die "Cannot write $csvfile\n";
    my @labels=@{$labels{$climber}{$location}};
    
    print CSV "secs,".join(',',@labels)."\n";
    foreach my $time (sort {$a <=> $b} keys %{$times{$climber}{$location}}) {
	print CSV "$time";
	foreach my $label (@labels) {
	    my $data=$ascends{$climber}{$location}{$label}{$time} || "NaN";
	    print CSV ",$data";
	};
	print CSV "\n";
    };
    close(CSV);

    # HTML file to link to a dygraphs invocation
    my $htmlfile="$dir/$date-$locf.html";
    open(HTML, ">$htmlfile") or die "Cannot write $htmlfile\n";

    my $stats="&tr=".$totals{$climber}{$location}{'routes'}."&td=".$totals{$climber}{$location}{'duration'}."&ta=".$totals{$climber}{$location}{'maxaltsum'};

    print "$date $location $climber ".$totals{$climber}{$location}{'routes'}." ascents\n";
    
    print HTML <<EoT;
<html xmlns="http://www.w3.org/1999/xhtml">    
 <head>      
 <title></title>
  <!-- Change charset to utf-8 if needed by the www server setup  :) -->      
 <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />     
 <meta http-equiv="refresh"
   content="0;URL='../show.html?file=$climber/$date-$locf.csv&date=$date&climber=$climber$stats&loc=$location'" />
 </head>    
 <body> 
 </body>  
</html>
EoT
    close(HTML);
};

  }; # location loop  
    
    
}; # climber loop

